import Foundation
import Swinject
<%_ 
    let imports: [String]!

    if let _imports = (argument["imports"] as? [String]) {
      imports =  _imports
    } else if let _import = argument["imports"] as? String {
         imports = [_import]
    } else {
       imports =  []
    }
-%>
<%_ for `import` in imports { -%>
import <%= `import` %>
<%_ } -%>

<%- include("AnnotationInject.swift") -%>
<%- include("Partials/Method.swift") -%>
<%- include("Partials/String.swift") -%>

typealias ServiceResolver = Resolver

/// Defines methods to *safely* access injected dependencies
extension ServiceResolver {
<%_ for service in ServiceProvider(types: types).findAnnotatedServices() { -%>
    <%_ let method = service.factory -%>
    <%_ let parameters = method.parameters.filter(annotated: "provided") -%>

    func <%= service.functionName %>(<%= stringify(parameters: parameters, printing: .definition) %>) -> <%= service.resolvedTypeName %> {
        return resolve(<%= method.returnTypeName %>.self<%= prefixNonEmpty(concatParamNames(of: parameters), with: ", arguments: ") %>)!
    }
<%_ } -%>

<%_ for service in ServiceProvider(types: types).findFactoryServices() { -%>
    <%_ let method = service.factory -%>
    <%_ let parameters = method.parameters.filter(annotated: "provided") -%>

    func <%= service.functionName %>(<%= stringify(parameters: parameters, printing: .definition) %>) -> <%= service.resolvedTypeName %> {
        return resolve(<%= method.returnTypeName %>.self<%= prefixNonEmpty(concatParamNames(of: parameters), with: ", arguments: ") %>)!
    }
<%_ } -%>
}

extension Resolver {
  public func resolve<T, U1>(_ serviceType: T.Type, arguments: U1) -> T? {
    return resolve(serviceType, argument: arguments)
  }
}
